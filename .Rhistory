ggplot(df2, aes(DOSEN, RG)) +
geom_point(size = 4, color = "red") +
geom_smooth(se = FALSE,
method = "lm",
formula = y ~ poly(x, 2)) +
scale_x_continuous(breaks = DOSEN) +
labs(x = "Dose de N (Kg/ha)",
y = "Rendimento de grãos (t/ha)")
p1
p1 +
labs(title = "Equação quadrática",
subtitle = "Trigângulo e cículo representam os pontos de MME e MET, respectivamente",
caption = "MME = Máxima eficiência econômica\n MET = máxima eficiência técnica") +
# Linhas e ponto da MET
geom_segment(aes(x = x_met, y = pred_met, xend = x_met, yend = 6.7)) +
geom_segment(aes(x = 0, y = pred_met, xend = x_met, yend = pred_met)) +
geom_point(aes(x = x_met, y = pred_met), shape = 19, size = 3, color = "blue") +
# Linhas e ponto da MEE
geom_segment(aes(x = x_mee, y = rg_mee, xend = x_mee, yend = 6.7), linetype = 2) +
geom_segment(aes(x = 0, y = rg_mee, xend = x_mee, yend = rg_mee), linetype = 2) +
geom_point(aes(x = x_mee, y = rg_mee), shape = 17, size = 3, color = "blue") +
# Equação no gráfico
geom_text(aes(0, 7.9,
label=(
paste(
expression("y = 7.075 + 0.007184x - 2,071e"^{-5}*"x"^2*"  R" ^2*" = 0,938 "))
)
),
hjust = 0,
size = 5,
col = "black",
parse = TRUE)
# ajustar modelo de regressão linear
mod <- lm(y ~ x, data = df)
# coeficientes
summary(mod)
# Análise de variância
anova(mod)
broom::tidy(mod)
broom::glance(mod)
broom::augment(mod)
# modelo ajustado o valor predito para x = 75
# função auxiliar
pred_linear <- function(mod, x){
b0 <- coef(mod)[[1]]
b1 <- coef(mod)[[2]]
pred <- b0 + b1 * x
return(pred)
}
pred_75 <- pred_linear(mod, 75)
pred_75
url <- "http://bit.ly/df_biostat_exp"
reg_ex <- import(url, sheet = "REG_EXERCICIO", setclass = "tbl")
reg_ex
url <- "http://bit.ly/df_biostat_exp"
cor_ex <- import(url, sheet = "COR_EXERCICIO", setclass = "tbl")
(x <- cor_ex$NGRA)
(y <- cor_ex$MGRA)
(n <- length(x))
(xy <- x * y)
(x2 <- x ^ 2)
(y2 <- y ^ 2)
# soma de xy
(somxy <- sum(xy))
# soma de x
(somx <- sum(x))
# soma de y
(somy <- sum(y))
# soma de x2
(somx2 <- sum(x2))
# soma de y2
(somy2 <- sum(y2))
# adiciona as colunas nos dados originais usando mutate()
cor_ex <-
mutate(cor_ex,
xy = xy,
x2 = x2,
y2 = y2)
data.frame(cor_ex)
# soma de produtos xy
(sxy <- somxy - (somx * somy / n))
# soma de quadrados de x
(sx <- somx2 - somx ^ 2 / n)
# soma de quadrados de y
(sy <- somy2 - somy ^ 2 / n)
# coeficiente de correlaçao
(r <- sxy / (sqrt(sx * sy)))
# t calculado
(tc <- r * sqrt((n - 2) / (1 - r ^ 2)))
# t tabelado (cauda direita) = 2.16
# como é bicaudal, considera-se 0.05 / 2
qt(0.025, df = 13, lower.tail = FALSE)
# somente calcula o r
cor(x, y)
# computa o r e realiza o teste de hipótese
cor.test(x, y)
# t tabelado (cauda direita) = 2.16
# como é bicaudal, considera-se 0.05 / 2
qt(0.025, df = 13, lower.tail = FALSE)
# computa o r e realiza o teste de hipótese
cor.test(x, y)
# t tabelado (cauda direita) = 2.16
# como é bicaudal, considera-se 0.05 / 2
qt(0.975, df = 13, lower.tail = FALSE)
# t tabelado (cauda direita) = 2.16
# como é bicaudal, considera-se 0.05 / 2
qt(0.025, df = 13, lower.tail = T)
# t tabelado (cauda direita) = 2.16
# como é bicaudal, considera-se 0.05 / 2
qt(0.025, df = 13, lower.tail = FALSE)
tc
# computa o r e realiza o teste de hipótese
cor.test(x, y)
url <- "http://bit.ly/df_biostat_exp"
df_co2 <- import(url, sheet = "REG_PRATICA", setclass = "tbl")
(x <- df_co2$x)
(y <- df_co2$y)
(n <- length(x))
(mx <- mean(x))
(my <- mean(y))
df_co2
df_co2
clipr::write_clip(df_co2)
mod <- lm(y ~ x)
summary(mod)
mod <- lm(y ~ x)
summary(mod)
predict(mod)
x
summary(mod)
url <- "http://bit.ly/df_biostat_exp"
reg_ex <- import(url, sheet = "REG_EXERCICIO", setclass = "tbl")
# Chunk 1
library(tidyverse)
library(metan)      # estatísticas descritivas
library(rio)        # importação/exportação de dados
library(AgroR)
library(broom)
# Chunk 2
x <- seq(0, 150, by = 25)
y <- c(8.6, 8.9, 9.5, 9.9, 10, 10.2, 10.5)
df <- data.frame(x = x, y = y)
# plotar os valores
ggplot(df, aes(x, y)) +
geom_point(size = 4, color = "red") +
geom_smooth(se = FALSE, method = "lm") +
scale_x_continuous(breaks = x) +
labs(x = "Dose de N (Kg/ha)",
y= "Rendimento de grãos (t/ha)")
# Chunk 3
df2 <-
mutate(df,
x2 = x ^ 2,
y2 = y ^ 2,
xy = x * y)
df2
# número de pontos
(n <- length(x))
# soma de xi
(sum_xi <- sum(x))
# soma de xi ao quadrado
(sum_xi2 <- sum(x ^ 2))
# soma de yi
(sum_yi <- sum(y))
# soma de yi ao quadrado
(sum_yi2 <- sum(y ^ 2))
# soma de xi * yi
(sum_xiyi <- sum(x * y))
# Chunk 4
colSums(df2)
apply(df2, 2, sum)
# Chunk 5
# soma de produtos de X e Y
(SPxy <- sum_xiyi - (sum_xi * sum_yi) / n)
# soma de quadrados de X
(SQx <- sum_xi2 - (sum_xi ^2) / n)
# soma de quadrados de Y
(SQy <- sum_yi2 - (sum_yi ^ 2) / n)
# computar o b1
(b1 <- SPxy / SQx)
# computar o b0
(b0 <- mean(y) - b1 * mean(x))
# Chunk 6
# soma de quadrado total
(SQtot <- SQy)
(SQreg <- SPxy ^ 2 / SQx)
(SQerro <- SQtot - SQreg)
# Chunk 7
FV <- c("Regressão", "Desvio", "Total")
GL <- c(1, n - 2, n - 1)
SQ <- c(SQreg, SQerro, SQtot)
QM <- SQ / GL
FC <- c(QM[[1]] / QM[[3]], NA, NA)
data.frame(FV, GL, SQ, QM, FC) |> knitr::kable()
# Chunk 8
(R2 <- SQreg / SQtot)
# Chunk 9
R2adj <- 1 - ((n - 1)*(1 - R2)) / (n - 2)
R2adj
# Chunk 10
(pred <- b0 + b1 * x)
# Chunk 11
(desvios <- y - pred)
# Chunk 12
# gráfico base
ggplot(df, aes(x, y)) +
geom_segment(aes(x = x,
y = y,
xend = x,
yend = pred)) +
geom_point(size = 4, color = "red") +
geom_smooth(se = FALSE, method = "lm") +
scale_x_continuous(breaks = x) +
labs(x = "Dose de N (Kg/ha)",
y= "Rendimento de grãos (t/ha)")
# Chunk 13
sum(desvios ^ 2)
# Chunk 14
# ajustar modelo de regressão linear
mod <- lm(y ~ x, data = df)
# coeficientes
summary(mod)
# Análise de variância
anova(mod)
# Chunk 15
# valores preditos
pred <-
df %>%
mutate(predito = predict(mod),
residual = y - predito)
pred
# Chunk 16
# modelo ajustado o valor predito para x = 75
# função auxiliar
pred_linear <- function(mod, x){
b0 <- coef(mod)[[1]]
b1 <- coef(mod)[[2]]
pred <- b0 + b1 * x
return(pred)
}
pred_75 <- pred_linear(mod, 75)
pred_75
ggplot(df, aes(x, y)) +
geom_smooth(se = FALSE, method = "lm") +
geom_segment(aes(x = 75, y = 8.5, xend = 75, yend = pred_75)) +
geom_segment(aes(x = 0, y = pred_75, xend = 75, yend = pred_75)) +
geom_point(aes(x = 75, y = pred_75), color = "blue", size = 4) +
geom_point(size = 4, color = "red") +
scale_x_continuous(breaks = x) +
labs(x = "Dose de N (Kg/ha)",
y= "Rendimento de grãos (t/ha)",
title = "Reta predita para o modelo de regressão",
subtitle = "O ponto azul representa o RG predito com 75 kg/ha de N")
# Chunk 17
url <- "http://bit.ly/df_biostat_exp"
df_reg <- import(url, sheet = "REG_DEL_DATA", setclass = "tbl")
# anova em DBC
df_factors <- df_reg %>% as_factor(1:2)
anova <- aov(RG ~ DOSEN + BLOCO, data = df_factors)
tidy(anova) %>% as.data.frame()
# regressão
reg <- lm(RG ~ DOSEN, data = df_reg)
tidy(reg) %>% as.data.frame()
# anova da regressão
anova_reg <- aov(reg)
tidy(anova_reg) %>% as.data.frame() %>% slice(1)
# pontos plotados
ggplot(df_reg, aes(DOSEN, RG)) +
geom_point(color = "red") +
stat_summary(geom = "point",
fun = mean,
shape = 23) +
labs(x = "Dose de N (Kg/ha)",
y = "Rendimento de grãos (t/ha)") +
geom_smooth(method = "lm", se = FALSE)
# Chunk 18
DOSEN <- c(0, 50, 100, 150, 200, 250)
RG    <- c(7.1, 7.3, 7.66, 7.71, 7.62, 7.6)
df2 <- data.frame(DOSEN = DOSEN, RG = RG)
# modelo de regressão
mod2 <- lm(RG ~ poly(DOSEN, 2, raw = TRUE), data = df2)
summary(mod2)
# valores preditos
pred2 <-
df2 %>%
mutate(predito = predict(mod2),
residual = RG - predito)
pred2
# gráfico base
p1 <-
ggplot(df2, aes(DOSEN, RG)) +
geom_point(size = 4, color = "red") +
geom_smooth(se = FALSE,
method = "lm",
formula = y ~ poly(x, 2)) +
scale_x_continuous(breaks = DOSEN) +
labs(x = "Dose de N (Kg/ha)",
y = "Rendimento de grãos (t/ha)")
p1
# Chunk 19
# máxima eficiência técnica
# mod é o modelo quadrático ajustado
met <- function(mod){
b1 <- coef(mod)[[2]]
b2 <- coef(mod)[[3]]
res <- -b1 / (2 * b2)
return(res)
}
x_met <- met(mod2)
x_met
# Chunk 20
# valor predito para x = MET
# função auxiliar
pred_quad <- function(mod, x){
b0 <- coef(mod)[[1]]
b1 <- coef(mod)[[2]]
b2 <- coef(mod)[[3]]
pred <- b0 + b1 * x + b2 * x ^ 2
return(pred)
}
pred_met <- pred_quad(mod2, x = x_met)
pred_met
# Chunk 21
mee <- function(mod, px, py){
x_met <- met(mod)
mee <- x_met + px / (2 * coef(mod)[[3]] * py)
return(mee)
}
x_mee <- mee(mod2, 3, 1300)
x_mee
# Chunk 22
# Máxima eficiência econõmica (y)
rg_mee <- pred_quad(mod2, x = x_mee)
rg_mee
# Chunk 23
p1 +
labs(title = "Equação quadrática",
subtitle = "Trigângulo e cículo representam os pontos de MME e MET, respectivamente",
caption = "MME = Máxima eficiência econômica\n MET = máxima eficiência técnica") +
# Linhas e ponto da MET
geom_segment(aes(x = x_met, y = pred_met, xend = x_met, yend = 6.7)) +
geom_segment(aes(x = 0, y = pred_met, xend = x_met, yend = pred_met)) +
geom_point(aes(x = x_met, y = pred_met), shape = 19, size = 3, color = "blue") +
# Linhas e ponto da MEE
geom_segment(aes(x = x_mee, y = rg_mee, xend = x_mee, yend = 6.7), linetype = 2) +
geom_segment(aes(x = 0, y = rg_mee, xend = x_mee, yend = rg_mee), linetype = 2) +
geom_point(aes(x = x_mee, y = rg_mee), shape = 17, size = 3, color = "blue") +
# Equação no gráfico
geom_text(aes(0, 7.9,
label=(
paste(
expression("y = 7.075 + 0.007184x - 2,071e"^{-5}*"x"^2*"  R" ^2*" = 0,938 "))
)
),
hjust = 0,
size = 5,
col = "black",
parse = TRUE)
# Chunk 24
url <- "http://bit.ly/df_biostat_exp"
df_mat <-
import(url, sheet = "maize", setclass = "tbl") |>
select(APLA:MGRA)
# correlação de pearson (AP e A)
cor(df_mat$APLA, df_mat$AIES)
# Chunk 25
# Matriz gráfica de correlação
cor(df_mat)
# Chunk 26
# Matriz gráfica de correlação
corr_plot(df_mat)
url <- "http://bit.ly/df_biostat_exp"
reg_ex <- import(url, sheet = "REG_EXERCICIO", setclass = "tbl")
reg_ex
(x <- reg_ex$DOSE)
(y <- reg_ex$RG)
# número de amostras
(n <- length(x))
# médias
(mx <- mean(x))
(my <- mean(y))
# x vezes y
(xy <- x * y)
# x ao quadrado
(x2 <- x ^ 2)
# y ao quadrado
(y2 <- y ^ 2)
# soma de xy
(somxy <- sum(xy))
# soma de x
(somx <- sum(x))
# soma de y
(somy <- sum(y))
# soma de x2
(somx2 <- sum(x2))
# soma de y2
(somy2 <- sum(y2))
# soma de produtos xy
(sxy <- somxy - (somx * somy / n))
# soma de quadrados de x
(sx <- somx2 - somx ^ 2 / n)
# soma de quadrados de y
(sy <- somy2 - somy ^ 2 / n)
## coeficientes
# b1
(b1 <- sxy / sx)
# b0
(b0 <- my - mx * b1)
b1
b0
######### ANOVA
# soma de quadrado total
(sqt <- sy)
# soma de quadrados da regressão
(sqreg <- sxy ^ 2 / (sx))
# soma de quadrados do resíduo
(sqres <- sqt - sqreg)
# coeficiente de determinação
R2 <- sqreg / sqt
# coeficiente de determinação
(R2 <- sqreg / sqt)
# y predito com x = 35
(yx35 <- b0 + b1 * 35)
reg <- lm(y ~ x)
# coeficientes e R2
summary(reg)
# anova
anova(reg)
library(ggpmisc) # adiciona a equação no gráfico
ggplot(reg_ex, aes(DOSE, RG)) +
geom_smooth(se = FALSE, method = "lm") +
geom_segment(aes(x = 35, y = 7000, xend = 35, yend = yx35)) +
geom_segment(aes(x = 18, y = yx35, xend = 35, yend = yx35)) +
geom_point(aes(x = 35, y = yx35), color = "red", size = 4) +
geom_point(size = 4, color = "blue") +
stat_poly_eq(formula = y ~ x,
aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~")),
coef.digits = 5) +
labs(x = "Dose de dejeto (m3/ha)",
y = "Rendimento de grãos (kg/ha)")
ggplot(reg_ex, aes(DOSE, RG)) +
geom_smooth(se = FALSE, method = "lm") +
geom_point(size = 4, color = "blue") +
stat_poly_eq(formula = y ~ x,
aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~")),
coef.digits = 5) +
labs(x = "Dose de dejeto (m3/ha)",
y = "Rendimento de grãos (kg/ha)")
ggplot(reg_ex, aes(DOSE, RG)) +
geom_smooth(se = FALSE, method = "lm") +
geom_point(size = 4, color = "blue") +
stat_poly_eq(formula = y ~ x,
# aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~")),
coef.digits = 5) +
labs(x = "Dose de dejeto (m3/ha)",
y = "Rendimento de grãos (kg/ha)")
ggplot(reg_ex, aes(DOSE, RG)) +
geom_smooth(se = FALSE, method = "lm") +
geom_point(size = 4, color = "blue") +
stat_poly_eq(formula = y ~ x,
aes(label = paste(..eqs.label.., ..rr.label.., sep = "~~~")),
coef.digits = 5) +
labs(x = "Dose de dejeto (m3/ha)",
y = "Rendimento de grãos (kg/ha)")
ggplot(reg_ex, aes(DOSE, RG)) +
geom_smooth(se = FALSE, method = "lm") +
geom_point(size = 4, color = "blue") +
stat_poly_eq(formula = y ~ x,
aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~")),
coef.digits = 5) +
labs(x = "Dose de dejeto (m3/ha)",
y = "Rendimento de grãos (kg/ha)")
ggplot(reg_ex, aes(DOSE, RG)) +
geom_smooth(se = FALSE, method = "lm") +
geom_point(size = 4, color = "blue") +
stat_poly_eq(formula = y ~ x,
aes(label = paste(..eq.label.., ..rr.label.., sep = "~")),
coef.digits = 5) +
labs(x = "Dose de dejeto (m3/ha)",
y = "Rendimento de grãos (kg/ha)")
ggplot(reg_ex, aes(DOSE, RG)) +
geom_smooth(se = FALSE, method = "lm") +
geom_point(size = 4, color = "blue") +
stat_poly_eq(formula = y ~ x,
aes(label = paste(..eq.label.., ..rr.label.., sep = "~~|~")),
coef.digits = 5) +
labs(x = "Dose de dejeto (m3/ha)",
y = "Rendimento de grãos (kg/ha)")
ggplot(reg_ex, aes(DOSE, RG)) +
geom_smooth(se = FALSE, method = "lm") +
geom_point(size = 4, color = "blue") +
stat_poly_eq(formula = y ~ x,
aes(label = paste(..eq.label.., ..rr.label.., sep = "~~\\~")),
coef.digits = 5) +
labs(x = "Dose de dejeto (m3/ha)",
y = "Rendimento de grãos (kg/ha)")
ggplot(reg_ex, aes(DOSE, RG)) +
geom_smooth(se = FALSE, method = "lm") +
geom_point(size = 4, color = "blue") +
stat_poly_eq(formula = y ~ x,
aes(label = paste(..eq.label.., ..rr.label.., sep = "~~\~")),
coef.digits = 5) +
labs(x = "Dose de dejeto (m3/ha)",
y = "Rendimento de grãos (kg/ha)")
ggplot(reg_ex, aes(DOSE, RG)) +
geom_smooth(se = FALSE, method = "lm") +
geom_point(size = 4, color = "blue") +
stat_poly_eq(formula = y ~ x,
aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~~")),
coef.digits = 5) +
labs(x = "Dose de dejeto (m3/ha)",
y = "Rendimento de grãos (kg/ha)")
