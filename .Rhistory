set_wd_here()
img <- image_import("test.png")
plot(img)
image_index(img) |> plot()
image_segment(img, "B")
image_segment(img, "B", filter = 3)
image_segment(img, "B", filter = 5)
analyze_objects(img, "B")
res <- analyze_objects(img)
res <- analyze_objects(img, "L")
image_segment(img, index = "all")
image_segment(img, index = "G-R")
res <- analyze_objects(img, "G-R")
View(res)
View(res[["results"]])
res <- analyze_objects(img, "G-R",
topn_upper = 3)
set_wd_here()
gn18 <- image_import("gn18.jpg", plot = TRUE)
image_segment_iter(gn18)
gn18 <- image_import("gn18.jpg", plot = TRUE) |> image_resize(30)
image_segment_iter(gn18)
analyze_objects(gn18,
reference = TRUE,
reference_area = 4,
back_fore_index = "B-R",
fore_ref_index = "BI")
analyze_objects(gn18,
reference = TRUE,
reference_area = 4,
back_fore_index = "B-R",
fore_ref_index = "G-R")
analyze_objects(gn18,
reference = TRUE,
reference_area = 4,
back_fore_index = "B-R",
fore_ref_index = "G-R",
invert = c(FALSE, TRUE))
analyze_objects(gn18,
reference = TRUE,
reference_area = 4,
back_fore_index = "B-R",
fore_ref_index = "HUE")
analyze_objects(gn18,
reference = TRUE,
reference_area = 4,
back_fore_index = "B-R",
fore_ref_index = "HUE",
watershed = FALSE,
marker = id)
analyze_objects(gn18,
reference = TRUE,
reference_area = 4,
back_fore_index = "B-R",
fore_ref_index = "HUE",
watershed = FALSE,
marker = "id")
res
res <-
analyze_objects(gn18,
reference = TRUE,
reference_area = 4,
back_fore_index = "B-R",
fore_ref_index = "HUE",
watershed = FALSE,
marker = "id")
res
res$results$area
get_measures(res)
get_measures(res) |> t()
mgn18 <- analyze_objects("gn18", marker = "id", col_background = "white", show_original = FALSE)
res <-
analyze_objects(gn18,
watershed = FALSE,
marker = "id")
res <-
analyze_objects(gn18,
reference = TRUE,
reference_area = 9,
back_fore_index = "B-R",
fore_ref_index = "HUE",
watershed = FALSE,
marker = "id")
get_measures(res) |> t()
get_measures(res2, id = 6, area ~ 9) |>  t()
res2 <-
analyze_objects(gn18,
watershed = FALSE,
marker = "id")
get_measures(res2, id = 6, area ~ 9) |>  t()
library(metan)
df <- clip_read()
df
aov(RG ~ HIBRIDO, data = df) |> summary()
library(rio)
df <- import("https://docs.google.com/spreadsheets/d/1vpVGdIkggRxmdnwrkllHbVA0TIHN85UK/edit#gid=1486281449",
dec = ",")
df <- import("https://docs.google.com/spreadsheets/d/1vpVGdIkggRxmdnwrkllHbVA0TIHN85UK/edit#gid=1486281449",
dec = ",")
View(df)
library(metan)
library(tidyverse)
df |>
pivot_wider(names_from = BLOCO,
values_from = RG)
df |>
pivot_wider(names_from = BLOCO,
values_from = RG) |>
row_col_sum()
df |>
pivot_wider(names_from = BLOCO,
values_from = RG) |>
as.matrix() |>
row_col_sum()
df |>
pivot_wider(names_from = BLOCO,
values_from = RG)
df |>
pivot_wider(names_from = BLOCO,
values_from = RG) |>
column_to_rownames("HIBRIDO") |>
row_col_sum()
library(rio)
library(metan)
library(tidyverse)
df <- import("https://docs.google.com/spreadsheets/d/1vpVGdIkggRxmdnwrkllHbVA0TIHN85UK/edit#gid=1486281449",
dec = ",")
View(df)
df |>
pivot_wider(names_from = BLOCO,
values_from = RG)
df |>
pivot_wider(names_from = BLOCO,
values_from = RG) |>
column_to_rownames("HIBRIDO")
df |>
pivot_wider(names_from = BLOCO,
values_from = RG) |>
column_to_rownames("HIBRIDO") |>
row_col_sum()
mat <-
df |>
pivot_wider(names_from = BLOCO,
values_from = RG) |>
column_to_rownames("HIBRIDO")
sums <- row_col_sum(mat)
sums
# soma de tratamento ao quadrado
apply(mat, 1, sum)
apply(mat, 1, sum)^2
# soma de tratamento ao quadrado
apply(mat, 1, sum)^2 |> sum()
sum(mat)^2 / 20
C <- sum(mat)^2 / 20
(apply(mat, 1, sum)^2 |> sum())/4
# soma de tratamento ao quadrado
sqt <- ((apply(mat, 1, sum)^2 |> sum())/4)-C
mat
mat^2
mat^2 |> sum()
sqtot <- (mat^2 |> sum()) - C
# soma de quadrados de erro
sqe <- sqtot - sqt
I <- 5
J <- 4
# quadrado médio de tratamento
qmt <- sqt / (I-1)
# quadrado médio do erro
qme <- sqe / I*(J-1)
I*(J-1)
# quadrado médio do erro
qme <- sqe / (I*(J-1))
sqtot / 19
var(mat)
ma
mat
var(mat)
var(mat |> as.vector())
c(mat)
var(mat |> as.matrix())
as.matrix(mat)
as.matrix(mat) |> as.vector()
as.matrix(mat) |> as.vector() |> var()
sqtot / 19
# F calculado
fcal <- qmt / qme
mat <-
df |>
pivot_wider(names_from = BLOCO,
values_from = RG) |>
column_to_rownames("HIBRIDO") |>
as.matrix()
var(mat)
View(mat)
sums <- row_col_sum(mat)
View(df)
ggplot(df, aes(HIBRIDO, RG))+
geom_boxplot()
ggplot(df, aes(HIBRIDO, RG))+
geom_boxplot() +
stat_summary(geom = "point",
fun = mean)
ggplot(df, aes(HIBRIDO, RG))+
geom_boxplot() +
stat_summary(geom = "point",
fun = mean,
shape  = 3)
View(df)
ggplot(df, aes(HIBRIDO, RG))+
geom_boxplot(aes(fill = BLOCO)) +
stat_summary(geom = "point",
fun = mean,
shape  = 3)
ggplot(df, aes(HIBRIDO, RG))+
geom_col(aes(fill = BLOCO)) +
stat_summary(geom = "point",
fun = mean,
shape  = 3)
ggplot(df, aes(HIBRIDO, RG))+
geom_col(aes(fill = BLOCO),
position = position_dodge()) +
stat_summary(geom = "point",
fun = mean,
shape  = 3)
df |>
mean_by(HIBRIDO)
ggplot(df, aes(BLOCO, RG))+
geom_boxplot() +
stat_summary(geom = "point",
fun = mean,
shape  = 3)
?aov
View(df)
View(mat)
# anova com a função aov()
mod <- aov(RG ~ HIBRIDO, data = df)
summary(mod)
df1 <- 4
df2 <- 15
fcal <- 2.2543
ftab <- 3.055
ggplot() +
scale_x_continuous(limits = c(0,  6),
breaks = c(0,  fcal, ftab,  6)) +
stat_function(fun = df,
geom = "area",
fill = "red",
xlim = c(fcal, 6),
args = list(
df1 = df1,
df2 = 63
)) +
stat_function(fun = df,
geom = "area",
fill = "forestgreen",
xlim = c(ftab, 6),
args = list(
df1 = df1,
df2 = 63
)) +
stat_function(fun = df,
geom = "line",
size = 1,
args = list(
df1 = df1,
df2 = 63
)) +
theme_bw(base_size = 16) +
theme(panel.grid.minor = element_blank()) +
scale_y_continuous(expand = expansion(mult = c(0, .1)))+
labs(x = "Valor de F",
y = "Probabilidade acumulada",
title = "Distribuição F (DF1: 4, DF2: 15)")
df1 <- 4
df2 <- 15
fcal <- 2.2543
ftab <- 3.055
ggplot() +
scale_x_continuous(limits = c(0,  6),
breaks = c(0,  fcal, ftab,  6)) +
stat_function(fun = df,
geom = "area",
fill = "red",
xlim = c(fcal, 6),
args = list(
df1 = df1,
df2 = 63
)) +
stat_function(fun = df,
geom = "area",
fill = "forestgreen",
xlim = c(ftab, 6),
args = list(
df1 = df1,
df2 = 63
)) +
stat_function(fun = df,
geom = "line",
size = 1,
args = list(
df1 = df1,
df2 = 63
)) +
theme_bw(base_size = 16) +
theme(panel.grid.minor = element_blank()) +
scale_y_continuous(expand = expansion(mult = c(0, .1)))+
labs(x = "Valor de F",
y = "Probabilidade acumulada",
title = "Distribuição F (DF1: 4, DF2: 15)")
library(agricolae)
?design.alpha
trt<-1:100
t <- length(trt)
# size block k
k<-3
# size block k
k<-10
# Blocks s
s<-t/k
# replications r
r <- 2
outdesign<- design.alpha(trt,k,r,serie=2)
book<-outdesign$book
book
trt<-1:90
t <- length(trt)
# size block k
k<-10
# Blocks s
s<-t/k
# replications r
r <- 2
outdesign<- design.alpha(trt,k,r,serie=2)
# size block k
k<-9
# Blocks s
s<-t/k
# replications r
r <- 2
outdesign<- design.alpha(trt,k,r,serie=2)
book<-outdesign$book
# size block k
k<-10
# Blocks s
s<-t/k
# replications r
r <- 2
outdesign<- design.alpha(trt,k,r,serie=2)
open_wd_here()
12*6
library(rio)
library(tidyverse)
library(metan)
df <- import("https://docs.google.com/spreadsheets/d/1vpVGdIkggRxmdnwrkllHbVA0TIHN85UK/edit#gid=1486281449",
dec =",")
View(df)
mat <- pivot_wider(df,
names_from = BLOCO,
values_from = RG)
View(mat)
mat <- pivot_wider(df,
names_from = BLOCO,
values_from = RG) |>
column_to_rownames("HIBRIDO")
View(mat)
mat <- pivot_wider(df,
names_from = BLOCO,
values_from = RG) |>
column_to_rownames("HIBRIDO") |>
row_col_sum()
View(mat)
I <- 5
J <- 4
View(mat)
mat <- pivot_wider(df,
names_from = BLOCO,
values_from = RG) |>
column_to_rownames("HIBRIDO")
sum <- row_col_sum(mat)
mat <- pivot_wider(df,
names_from = BLOCO,
values_from = RG) |>
column_to_rownames("HIBRIDO")
View(mat)
sum <- row_col_sum(mat)
I <- 5
J <- 4
sum(mat)
sum(mat)^2
C <- sum(mat)^2 / (I*J)
# SOMA DE QUADRADO TOTAL
mat^2
# SOMA DE QUADRADO TOTAL
mat^2 |> sum()
sum(mat^2)
sum(mat^2)
C
sqt <- sum(mat^2) - C
View(sum)
View(mat)
apply(mat, 1, sum)
# SOMA DE QUADRADO DE TRATAMENTO
apply(mat, 1, sum)^2
# SOMA DE QUADRADO DE TRATAMENTO
apply(mat, 1, sum)^2 |> sum()
# SOMA DE QUADRADO DE TRATAMENTO
((apply(mat, 1, sum)^2 |> sum()) / J) - C
# SOMA DE QUADRADO DE TRATAMENTO
sqt <- ((apply(mat, 1, sum)^2 |> sum()) / J) - C
# SOMA DE QUADRADO TOTAL
sqtot <- sum(mat^2) - C
# SOMA DE QUADRADO DE TRATAMENTO
sqtra <- ((apply(mat, 1, sum)^2 |> sum()) / J) - C
# SOMA DE QUADRADO DE ERRO
sqerr <- sqtot - sqtra
glt <- I*J-1
gltot <- I*J-1
gltra <- I-1
I*(J-1)
glerr <- I*(J-1)
qmtra <- sqtra/gltra
qmerr <- sqerr/glerr
qmtot <- sqtot/gltot
# F CALCULADO
fcal <- qmtra/qmerr
mat |> row_col_mean()
qmtot
c(mat)
as.numeric(mat)
c(as.matrix(mat))
var(c(as.matrix(mat)))
c(as.matrix(mat))
var(c(as.matrix(mat)))
View(df)
ggplot(df, aes(HIBRIDO, RG))+
geom_boxplot()
ggplot(df, aes(HIBRIDO, RG))+
geom_boxplot() +
stat_summary(geom = "point",
fun =mean,mapping = shape= 3)
ggplot(df, aes(HIBRIDO, RG))+
geom_boxplot() +
stat_summary(geom = "point",
fun =mean,
shape= 3)
View(df)
ggplot(df, aes(HIBRIDO, RG))+
geom_col(aes(fill = BLOCO),
position = position_dodge())
ggplot(df, aes(HIBRIDO, RG))+
geom_col(aes(fill = BLOCO),
position = position_dodge()) +
stat_summary(geom = "point",
fun =mean,
shape= 3)
ggplot(df, aes(BLOCO, RG))+
geom_boxplot() +
stat_summary(geom = "point",
fun =mean,
shape= 3)
f_dist <- function(gl_trat,
gl_erro,
alpha_des = 0.05,
alpha_obs = NULL){
if (is.null(alpha_obs)){
alpha_obs <- alpha_des
}
library(glue)
xl <- qf(p = 1 - 0.05, df1 = gl_trat, df2 = gl_erro, ncp=0) + 6
df <- data.frame(X = seq(from = 0, to = xl, length = 1000))
ftab <- round(xl - 6, 3)
ftab <- glue("F tabelado: {ftab}")
p <-
ggplot(data = df, mapping=aes(x = X, y = df(x = X, df1 = gl_trat, df2 = gl_erro, ncp=0)))+
scale_x_continuous(breaks=seq(0, xl, 1))+
scale_y_continuous(expand = expansion(mult = c(0, .1))) +
geom_area(data = subset(df, X > qf(p = 1 - alpha_obs, df1 = gl_trat, df2 = gl_erro, ncp=0)),
aes(x=X, y=df(x = X, df1 = gl_trat, df2 = gl_erro, ncp=2)),
fill = "red",
alpha = 0.7) +
geom_area(data = subset(df, X > qf(p = 1-alpha_des, df1 = gl_trat, df2 = gl_erro, ncp=0)),
aes(x=X, y=df(x = X, df1 = gl_trat, df2 = gl_erro, ncp=2)),
fill = "green",
alpha = 0.7) +
geom_area(aes(x=X, y=df(x = X, df1 = gl_trat, df2 = gl_erro, ncp=2)),
color="black", fill="blue", alpha = 0.1)+
labs(x = "Valor do teste F", y = "Probabilidade acumulada") +
theme(panel.grid.minor = element_blank()) +
ggtitle("Função densidade da distribuição F",
subtitle = glue("GLtrat: {gl_trat}; GLerro: {gl_erro}; {ftab}")) +
theme_gray(base_size = 18) +
theme(panel.grid.minor = element_blank(),
legend.title = element_blank())
plot(p)
}
f_dist(4, 15, 0.05, 0.11)
?aov
mod <- aov(RG ~ HIBRIDO, data = df)
summary(mod)
mod <- aov(RG ~ HIBRIDO + BLOCO, data = df)
summary(mod)
# Chunk 1
knitr::opts_knit$set(root.dir = "E:/Desktop/UFSC/aulas/classes/RGV410046/data")
# Chunk 3
library(rio)
library(tidyverse)
library(metan)
# dados
maize <-
import("examples_data.xlsx",
sheet = "maize",
setclass = "tbl")
