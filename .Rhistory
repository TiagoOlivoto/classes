p1 +
geom_hline(yintercept =  medy) +
geom_hline(yintercept =  b0,
color = "red") +
geom_abline(intercept = b0,
slope = b1,
color = "blue")
p1
# Y predito com 75 kg de N
y <- b0 + b1 * 75
p1 <-
p1 +
geom_point(x = 75,
y = y,
size = 5,
color = "red")
p1
# gráfico de dispersão
p1 <-
ggplot(df, aes(DOSEN, RG)) +
geom_point(size  = 3)
p1
p1 <-
p1 +
geom_hline(yintercept =  b0,
color = "red") +
geom_abline(intercept = b0,
slope = b1,
color = "blue")
p1
# Y predito com 75 kg de N
y <- b0 + b1 * 75
p1 <-
p1 +
geom_point(x = 75,
y = y,
size = 5,
color = "red")
p1
# cálculo dos resíduos
df <-
df |>
mutate(ypred = b0 + b1 * DOSEN,
resid = RG - ypred)
p1 <-
p1 +
geom_segment(aes(x = DOSEN, y = RG,
xend = DOSEN, yend = df$ypred),
color = "green")
p1
p1 <-
p1 +
geom_segment(aes(x = DOSEN, y = RG,
xend = DOSEN, yend = df$ypred),
color = "green",
size = 3)
p1
p1 <-
p1 +
geom_segment(aes(x = DOSEN, y = RG,
xend = DOSEN, yend = df$ypred),
color = "green",
linewidth = 3)
p1
p1 <-
p1 +
geom_segment(aes(x = DOSEN, y = RG,
xend = DOSEN, yend = df$ypred),
color = "green",
linewidth = 1)
p1
p1 <-
p1 +
geom_point(x = 75,
y = y,
size = 5,
color = "red")
p1
# gráfico de dispersão
p1 <-
ggplot(df, aes(DOSEN, RG)) +
geom_point(size  = 3)
p1
p2 <-
p1 +
geom_hline(yintercept =  b0,
color = "red") +
geom_abline(intercept = b0,
slope = b1,
color = "blue")
p2
# Y predito com 75 kg de N
y <- b0 + b1 * 75
p3 <-
p2 +
geom_point(x = 75,
y = y,
size = 5,
color = "red")
p3
# cálculo dos resíduos
df <-
df |>
mutate(ypred = b0 + b1 * DOSEN,
resid = RG - ypred)
p4 <-
p3 +
geom_segment(aes(x = DOSEN, y = RG,
xend = DOSEN, yend = df$ypred),
color = "green",
linewidth = 3)
p4
p4 <-
p3 +
geom_segment(aes(x = DOSEN, y = RG,
xend = DOSEN, yend = df$ypred),
color = "green",
linewidth = 1)
p4
df
p4 <-
p3 +
geom_segment(aes(x = DOSEN, y = RG,
xend = DOSEN, yend = ypred),
color = "green",
linewidth = 1)
p4
# soma de quadrados da regressão
sqreg <- spxy ^ 2 / sqx
# soma de quadrado total
sqtot <- sqy
# soma de quadrado do resíduo (erro)
sqresid <- sqtot - sqreg
# soma de quadrados da regressão
sqreg <- spxy ^ 2 / sqx
# soma de quadrado total
sqtot <- sqy
# soma de quadrado do resíduo (erro)
sqresid <- sqtot - sqreg
# coeficiente de determinação
R2 <- sqreg / sqtot
R2
# AJUSTE USANDO A FUNÇÃO LM()
mod <- lm(RG ~ DOSEN, data = df)
anova(mod)
summary(mod)
# EXEMPLO QUADRÁTICA
df2 <-
df |>
mutate(RG = c(8.6, 8.9, 9.3, 9.4, 9.2, 9, 8.95))
p1 <-
ggplot(df2, aes(DOSEN, RG)) +
geom_point(size  = 3) +
geom_smooth(method = "lm", se = FALSE)
# VER O AJUSTE DA LINEAR
mod <- lm(RG ~ DOSEN, data = df2)
anova(mod)
summary(mod)
p1 +
geom_smooth(method = "lm",
formula = y ~ poly(x, 2),
se = FALSE,
color = "red")
p2 <-
p1 +
geom_smooth(method = "lm",
formula = y ~ poly(x, 2),
se = FALSE,
color = "red")
p2
# AJUSTAR A REGRESSÃO QUADRÁTICA
mod <- lm(RG ~ poly(DOSEN, 2, raw = TRUE), data = df2)
anova(mod)
summary(mod)
# MÁXIMA EFICIÊNCIA TÉCNICA
b1 <- coef(mod)[[2]]
b2 <- coef(mod)[[3]]
quadratica <- "a + b * x + c * x ^ 2"
D(quadratica, "x")
quadratica
quadratica <- a + b * x + c * x ^ 2
quadratica <- formula(a + b * x + c * x ^ 2)
quadratica <- as.formula(a + b * x + c * x ^ 2)
D(quadratica, "x")
as.formula(a + b * x + c * x ^ 2)
as.formula(a + b * x + c * x ^ 2)
quadratica <- as.formula("a + b * x + c * x ^ 2")
D(quadratica, "x")
D(a + b * x + c * x ^ 2, "x")
?D
quadratica <- expression(a + b * x + c * x ^ 2)
D(quadratica, "x")
b <- 2
c <- 1
x <- 5
b + c * (2 * x)
-b / (2 * c)
-b / (2 * c)
quadratica <- expression(b0 + b1 * x + b2 * x ^ 2)
D(quadratica, "x")
coef(mod)[[2]]
coef(mod)[[1]]
coef(mod)[[2]]
coef(mod)[[3]]
# MÁXIMA EFICIÊNCIA TÉCNICA
b1 <- coef(mod)[[2]]
b2 <- coef(mod)[[3]]
MET <- -b1 / (2 * b2)
MET
D(quadratica, "x")
MET
solve(b1 + b2 * (2 * x))
solve(b1 + b2 * (2 * x))
solve(b1 + b2 * (2 * x) = 0)
D(expression(b1 + b2 * (2 * x)), "x")
quadratica <- expression(b0 + b1 * x + b2 * x ^ 2)
D(quadratica, "x")
# correlação
df <- import(url, sheet = "CORRELACAO_DATA")
ggplot(df, aes(AP, AE)) +
geom_point()
corr_plot(df, -Planta)
# usando a função cor() do R
cor(df$AP, df$AE)
corr_plot(df, -Planta)
df2 <- data.frame(x = 1:10,
y = 1:10)
ggplot(df2, aes(x, y)) +
geom_point()
cor(df2$x, df2$y)
# matriz de correlação com o metan
corr_coef(data_ge2, PH:CW) |>
network_plot()
df2 <-
data.frame(x = 1:10,
y = 1:10)
df2
df
# usando a função cor() do R
cor(df$AP, df$AE)
corr_plot(df, -Planta)
# matriz de correlação com o metan
corr_coef(data_ge2, PH:CW) |>
network_plot()
# correlação
df <- import(url, sheet = "CORRELACAO_DATA")
ggplot(df, aes(AP, AE)) +
geom_point()
# usando a função cor() do R
cor(df$AP, df$AE)
# usando a função corr_plot()
corr_plot(df, -Planta)
# matriz de correlação com o metan
data_ge2
# matriz de correlação com o metan
data_ge2
# matriz de correlação com o metan
data_ge2
# matriz de correlação com o metan
data_ge2
corr_coef(data_ge2, PH:CW) |>
network_plot()
?mean
# meu computador (mudar de acordo)
setwd("E:/Desktop/UFSC/aulas/classes/RGV410046/data")
setwd("E:/Desktop/UFSC/aulas/classes/RGV410046/data/faostat")
library(tidyverse)
library(rio)
library(metan)
area <- import("area.xlsx")
producao <- import("producao.xlsx")
View(area)
area_long <-
area |>
tidy_colnames() |>                   # metan
pivot_longer(-PAIS,                  # tidyr
names_to = "ANO",
values_to = "AREA")
# ajustar dados (area)
area_long <-
area |>
tidy_colnames() |>                   # metan
pivot_longer(-PAIS,                  # tidyr
names_to = "ANO",
values_to = "AREA") |>
mutate(PAIS = toupper(PAIS))         # dplyr
View(area_long)
View(producao)
df_area_prod <-
producao |>
separate(ANO_PRODUCAO, into = c("ANO", "PRODUCAO"))
View(df_area_prod)
df_area_prod <-
producao |>
separate(ANO_PRODUCAO, into = c("ANO", "PRODUCAO")) |>          # tidyr
right_join(area_long)
df_area_prod <-
producao |>
separate(ANO_PRODUCAO, into = c("ANO", "PRODUCAO"))
d <- inner_join(area_long, producao)
View(d)
d <- inner_join(area_long, df_area_prod)
View(d)
?inner_join
?anti_join
d <- anti_join(area_long, df_area_prod)
View(area_long)
View(df_area_prod)
View(area_long)
View(df_area_prod)
df_area_prod <-
producao |>
separate(ANO_PRODUCAO, into = c("ANO", "PRODUCAO")) |>          # tidyr
right_join(area_long)
View(df_area_prod)
View(area_long)
View(producao)
View(area_long)
df_area_prod <-
producao |>
separate(ANO_PRODUCAO, into = c("ANO", "PRODUCAO")) |>          # tidyr
right_join(area_long) |>                                        # dplyr
mutate(AREA = replace(AREA, AREA == 0, NA),                     # dplyr
PRODUCAO = gsub("NA", NA, PRODUCAO),
PRODUCAO = replace(PRODUCAO, PRODUCAO == 0, NA)) |>
mutate(across(c(PRODUCAO, AREA), as.numeric),
PRODUTIVIDADE = PRODUCAO / AREA)
View(df_area_prod)
# mesmo usando funções do metan
df_area_prod2 <-
producao |>
separate(ANO_PRODUCAO, into = c("ANO", "PRODUCAO")) |>          # tidyr
replace_string(PRODUCAO, pattern = "NA", replacement = NA) |>   # metan
as_numeric(PRODUCAO) |>                                         # metan
right_join(area_long) |>                                        # dplyr
replace_zero(PRODUCAO, AREA) |>                                 # metan
mutate(PRODUTIVIDADE = PRODUCAO / AREA)                         # dplyr
View(df_area_prod2)
sum(df_area_prod$PRODUTIVIDADE)
sum(df_area_prod$PRODUTIVIDADE, na.rm = TRUE)
sum(df_area_prod2$PRODUTIVIDADE, na.rm = TRUE)
# função erro padrão da média
se <- function(x, na.rm = TRUE){
return(sd(x, na.rm = na.rm) / sqrt(length(na.omit(x))))
}
prod_med <-
df_area_prod |>
group_by(PAIS) |>
summarise(prod_min = min(PRODUTIVIDADE, na.rm = TRUE),
prod_mean = mean(PRODUTIVIDADE, na.rm = TRUE),
prod_max = max(PRODUTIVIDADE, na.rm = TRUE),
prod_se = se(PRODUTIVIDADE, na.rm = TRUE)) |>
remove_rows_na() |>
arrange(desc(prod_mean))
prod_med <-
df_area_prod |>
group_by(PAIS) |>
summarise(prod_min = min(PRODUTIVIDADE, na.rm = TRUE),
prod_mean = mean(PRODUTIVIDADE, na.rm = TRUE),
prod_max = max(PRODUTIVIDADE, na.rm = TRUE),
prod_se = se(PRODUTIVIDADE, na.rm = TRUE))
View(prod_med)
View(df_area_prod)
prod_med <-
df_area_prod |>
group_by(PAIS) |>
summarise(prod_min = min(PRODUTIVIDADE, na.rm = TRUE),
prod_mean = mean(PRODUTIVIDADE, na.rm = TRUE),
prod_max = max(PRODUTIVIDADE, na.rm = TRUE),
prod_se = se(PRODUTIVIDADE, na.rm = TRUE)) |>
remove_rows_na() |>
arrange(desc(prod_mean))
prod_med2 <-
df_area_prod |>
remove_rows_na() |>
group_by(PAIS) |>
summarise(prod_min = min(PRODUTIVIDADE, na.rm = TRUE),
prod_mean = mean(PRODUTIVIDADE, na.rm = TRUE),
prod_max = max(PRODUTIVIDADE, na.rm = TRUE),
prod_se = se(PRODUTIVIDADE, na.rm = TRUE)) |>
# remove_rows_na() |>
arrange(desc(prod_mean))
View(prod_med2)
View(prod_med)
prod_med2 <-
df_area_prod |>
remove_rows_na()
View(prod_med2)
prod_med2 <-
df_area_prod |>
# remove_rows_na() |>
group_by(PAIS) |>
summarise(prod_min = min(PRODUTIVIDADE, na.rm = TRUE),
prod_mean = mean(PRODUTIVIDADE, na.rm = TRUE),
prod_max = max(PRODUTIVIDADE, na.rm = TRUE),
prod_se = se(PRODUTIVIDADE, na.rm = TRUE)) |>
arrange(desc(prod_mean))
View(prod_med2)
View(prod_med)
View(prod_med)
# top3
top3 <-
prod_med |>
slice(1:3) |>
pull(PAIS)
# MÉDIA DOS TOP 3 E OUTROS
med_top3 <-
df_area_prod |>
mutate(top3 = ifelse(PAIS %in% top3, "yes", "no")) |>
group_by(top3) |>
summarise(mean = mean(PRODUTIVIDADE, na.rm = TRUE)) |>
pivot_wider(names_from = top3,
values_from = mean) |>
mutate(dif = yes - no)
View(med_top3)
df_ano <-
df_area_prod |>
filter(PAIS %in% top3) |>
mutate(ANO = as.numeric(ANO))
ggplot(df_ano, aes(ANO, PRODUTIVIDADE, color = PAIS)) +
geom_line(size = 1) +
geom_point(size  = 3) +
theme_bw(base_size = 16) +
scale_x_continuous(breaks = seq(1960, 2020, by = 5)) +
scale_y_continuous(breaks = seq(10, 40, by = 5)) +
theme(legend.position = "bottom",
panel.grid.minor = element_blank()) +
labs(x = "Ano de cultivo",
y = expression(Produtividade~(Mg~ha^{-1})),
color = "",
title = "Produtividade de mandioca de 1960 a 2020 dos TOP 3 países com maior produtividade",
subtitle = "Fonte: https://www.fao.org/faostat/en/#data/QCL",
caption = "Elaborado com o pacote ggplot2")
library(lubridate)
?yyy
?yr
dmy("2022")
year("2022")
?year
ymd("2022")
as.Date("2022")
as.Date(ISOdate("2020", 1, 1))
as.Date("2009-08-03")
library(tidyverse)
df <- tibble(PLANT = paste0("P", 1:5),
AP = rnorm(5, 170, 10),
MG = rnorm(5, 420, 30))
df
df <- tibble(PLANT = paste0("P", 1:5),
AP = rnorm(5, 170, 5),
MG = rnorm(5, 420, 30))
df
df <- tibble(PLANT = paste0("P", 1:5),
AP = rnorm(5, 170, 15),
MG = rnorm(5, 420, 30))
df
df |>
mutate(across(AP:MG, scale))
scale(df$MG)
d <- scale(df$MG)
View(d)
df$MG
df |>
mutate(across(AP:MG, min))
df |>
mutate(across(AP:MG, scale))
df
df |>
mutate(SELECT = case_when(AP > 20 ~ "Sim"))
df |>
mutate(SELECT = case_when(AP > 150 ~ "Sim"))
df |>
mutate(SELECT = case_when(AP > 180 ~ "Sim"))
df |>
mutate(SELECT = case_when(AP > 170 ~ "Sim"))
df |>
mutate(SELECT = case_when(AP > 170 ~ "Sim", TRUE ~ "Não"))
df |>
mutate(SELECT = case_when(AP > 170 ~ "Sim",  "Não"))
df |>
mutate(SELECT = ifelse(AP > 170, "Sim" "Não"))
df |>
mutate(SELECT = ifelse(AP > 170, "Sim" "Não"))
df |>
mutate(SELECT = ifelse(AP > 170, "Sim", "Não"))
df |>
mutate(SELECT = ifelse(MG > 400, "Sim", "Não"))
df |>
mutate(SELECT =
ifelse(MG > 400,
"Sim", "Não"))
df |>
count()
df |>
count(AP)
View(df)
View(df)
df <- [c(1, 3), 2] <- 175
df <- df[c(1, 3), 2] <- 175
df |>
count(AP)
df <- tibble(PLANT = paste0("P", 1:5),
AP = rnorm(5, 170, 15),
MG = rnorm(5, 420, 30))
df[c(1, 3), 2]
df[c(1, 3), 2] <- 175
df |>
count(AP)
df
df
df |>
count(AP)
